package model;

import com.gurobi.gurobi.*;
import java.util.*;

public class DiscreteTimeModel2 {

    /**
     * Implements the discrete-time formulation for RCPSP from Koné et al. 2011
     * "Event-based MILP models for resource-constrained project scheduling problems"
     * 
     * Variables: x_{it} = 1 if activity i starts at time t, 0 otherwise
     * Objective: minimize makespan (start time of dummy end activity)
     * Constraints:
     * (4) Precedence constraints
     * (5) Resource constraints  
     * (6) Each activity starts exactly once
     * (7) Dummy start activity at time 0
     * (8)/(9) Variable bounds and binary constraints
     */
    public static Result.ScheduleIntegerResult gurobiRcpspJ30(String file) throws Exception {
        // Create FileReader instance and get the data
        FileReader fileReader = new FileReader();
        FileReader.JobData data = fileReader.dataRead(file);

        // Initialize the Gurobi environment and model
        GRBEnv env = new GRBEnv();
        GRBModel model = new GRBModel(env);

        int[][] startTimes = DAGLongestPath.generateEarliestAndLatestStartTimes
                (data.jobPredecessors, data.jobDuration, data.horizon);
        int[] earliestStartTime = startTimes[0];
        int[] latestStartTime = startTimes[1];

        GRBVar[][] startingTimeVars = new GRBVar[data.numberJob][data.horizon];
        for (int i = 0; i < data.numberJob; i++) {
            for (int t = 0; t < data.horizon; t++) {
                if (t >= earliestStartTime[i] && t <= latestStartTime[i]) {
                    startingTimeVars[i][t] = model.addVar(0.0, 1.0, 0.0, GRB.BINARY, "startingTime[" +
                            i + "] at [" + t + "]");
                } else {
                    startingTimeVars[i][t] = null; // Or handle appropriately in constraints
                }
            }
        }


        // (3) Set the objective: minimize sum_{t=LSi} {ESi} t * x[n+1, t]
        GRBLinExpr obj = new GRBLinExpr();
        for (int t = earliestStartTime[data.numberJob - 1]; t <= latestStartTime[data.numberJob - 1]; t++) {
            obj.addTerm(t, startingTimeVars[data.numberJob - 1][t]);
        }
        model.setObjective(obj, GRB.MINIMIZE);

        // (4) Precedence constraints: sum_{t=ESj}^{LSj} t*x_{jt} >= sum_{t=ESi}^{LSi} t*x_{it} + p_i for all (i,j) in E
        // translations of precedence constraints 
        for (int j = 0; j < data.numberJob; j++) {
            for (int pred : data.jobPredecessors.get(j)) {
                int i = pred;
                GRBLinExpr left = new GRBLinExpr();
                GRBLinExpr right = new GRBLinExpr();

                // Left: sum_{t=ESj}^{LSj} t * x[j][t]
                for (int t = earliestStartTime[j]; t <= latestStartTime[j]; t++) {
                    left.addTerm(t, startingTimeVars[j][t]);
                }
                // Right: sum_{t=ESi}^{LSi} t * x[i][t] + p_i
                for (int t = earliestStartTime[i]; t <= latestStartTime[i]; t++) {
                    right.addTerm(t, startingTimeVars[i][t]);
                }
                right.addConstant(data.jobDuration.get(i));

                model.addConstr(left, GRB.GREATER_EQUAL, right, "precedence_" + i + "_" + j);
            }
        }

        // (5) Resource constraints: sum_{i=1}^n b_{ik} * sum_{tau=max(ESi,t-pi+1)}^{min(LSi,t)} x_{i,tau} <= B_k
        for (int k = 0; k < data.resourceCapacity.size(); k++) {
            for (int t = 0; t < data.horizon; t++) {
                GRBLinExpr resourceUsage = new GRBLinExpr();
                
                for (int i = 0; i < data.numberJob; i++) {
                    int resourceDemand = data.jobResource.get(i).get(k);
                    if (resourceDemand > 0) {
                        // Job i is active at time t if it started at time tau where t-p_i+1 <= tau <= t
                        int tauMin = Math.max(earliestStartTime[i], t - data.jobDuration.get(i) + 1);
                        int tauMax = Math.min(latestStartTime[i], t);
                        
                        // Only add terms if the range is valid
                        if (tauMin <= tauMax) {
                            for (int tau = tauMin; tau <= tauMax; tau++) {
                                if (tau >= 0 && tau < data.horizon) {
                                    resourceUsage.addTerm(resourceDemand, startingTimeVars[i][tau]);
                                }
                            }
                        }
                    }
                }
                
                model.addConstr(resourceUsage, GRB.LESS_EQUAL, data.resourceCapacity.get(k), 
                               "resource_" + k + "_time_" + t);
            }
        }

        // (6) Each activity must start exactly once: sum_{t=ESi}^{LSi} x_{it} = 1 for all i in A ∪ {n+1}
        for (int i = 0; i < data.numberJob; i++) {
            GRBLinExpr activityStart = new GRBLinExpr();
            for (int t = earliestStartTime[i]; t <= latestStartTime[i]; t++) {
                activityStart.addTerm(1.0, startingTimeVars[i][t]);
            }
            model.addConstr(activityStart, GRB.EQUAL, 1.0, "activity_start_once_" + i);
        }

        // (7) Dummy start activity constraint: x_{00} = 1 (activity 0 starts at time 0)
        if (data.numberJob > 0) {
            model.addConstr(startingTimeVars[0][0], GRB.EQUAL, 1.0, "dummy_start");
        }

        // (8) Variable bounds 
        // This is already handled by the variable creation above, so no additional constraints needed here.
        // Explicitly set variables to 0 for time periods outside valid windows
        /*for (int i = 0; i < data.numberJob; i++) {
            for (int t = 0; t < data.horizon; t++) {
                if (t < earliestStartTime[i] || t > latestStartTime[i]) {
                    model.addConstr(startingTimeVars[i][t], GRB.EQUAL, 0.0, "bound_" + i + "_" + t);
                }
            }
        }*/

        // (9) Binary variables TODO not necessary cause vars are set to GRB.BINARY when creating variables

        // apply serial SGS start Solution to model
        applySolutionWithGurobi(model, data.numberJob, data.jobDuration, HeuristicSerialSGS.serialSGS(data));

        // Write model to file and optimize
        model.write("linear_model.lp");
        model.optimize();

        Result.ScheduleIntegerResult scheduleIntegerResult = fillListsToReturn(model, data.jobDuration, data.numberJob);

        // Clean up Gurobi model and environment
        model.dispose();
        env.dispose();

        return scheduleIntegerResult;
    }

    private static void applySolutionWithGurobi(GRBModel model, int numberJob, List<Integer> jobDuration,
                                                List<Integer> startTimes) throws GRBException {
        model.update();
        for (int i = 0; i < numberJob; i++) {
            int startTime = startTimes.get(i); // Start time for job i
            // Get the variable corresponding to job i starting at startTime
            GRBVar var = model.getVarByName("startingTime[" + i + "] at [" + startTime + "]");
            if (var != null) {
                // Set the start value for the variable to 1 (job i starts at startTime)
                var.set(GRB.DoubleAttr.Start, 1.0);
            }
        }
        model.update();
    }

    private static Result.ScheduleIntegerResult fillListsToReturn(GRBModel model, List<Integer> jobDuration, int numJob) throws GRBException {

        // Safe solution in outputDict
        Map<Integer, Integer> outputDict = new HashMap<>();
        for (GRBVar var : model.getVars()) {
            if (var.get(GRB.DoubleAttr.X) > 0.5) { // Use > 0.5 for binary variables
                System.out.println(var.get(GRB.StringAttr.VarName) + " " + var.get(GRB.DoubleAttr.X));
                String varName = var.get(GRB.StringAttr.VarName);
                
                // Parse variable name: "startingTime[i] at [t]"
                if (varName.startsWith("startingTime[")) {
                    String[] parts = varName.split("\\] at \\[");
                    if (parts.length == 2) {
                        int jobId = Integer.parseInt(parts[0].substring("startingTime[".length()));
                        int startTime = Integer.parseInt(parts[1].substring(0, parts[1].length() - 1));
                        outputDict.put(jobId, startTime);
                    }
                }
            }
        }

        List<Integer> start = new ArrayList<>(numJob);
        List<Integer> finish = new ArrayList<>(numJob);

        for (int i = 0; i < numJob; i++) {
            start.add(0);
            finish.add(0);
        }

        // Fill start times
        for (Map.Entry<Integer, Integer> entry : outputDict.entrySet()) {
            start.set(entry.getKey(), entry.getValue());
        }

        // Fill finish times
        for (int i = 0; i < numJob; i++) {
            finish.set(i, start.get(i) + jobDuration.get(i));
        }
        return new Result.ScheduleIntegerResult(start, finish);
    }
}